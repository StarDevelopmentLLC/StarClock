{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the StarClock Wiki! This is designed to show you how you can use this library in your projects as well as go over the concepts. Please see the README in the main repository to see how to add this to your project. </p>"},{"location":"callbacks/","title":"Callbacks","text":"<p>When dealing with callbacks, the only other class you have to worry about is the ClockCallback The <code>CallbackHolder</code> class is used internally and not needed to be covered. The remainder of this file will use a <code>Timer</code> that lasts for 10 seconds. Please see Timers for this setup.  </p>"},{"location":"callbacks/#repeating-callbacks","title":"Repeating callbacks","text":"<p>You have already seen an example of a repeated callback in the basic usage class, I put that there because that is the type that will be used the most.</p>"},{"location":"callbacks/#one-time-callbacks","title":"One-Time Callbacks","text":"<p>These are callbacks that are called once, relative to the elapsed time of the clock. So in my example, lets say I want to have it also print a message at 5 seconds, look below for an example <pre><code>timer.addCallback(snapshot -&gt; System.out.println(\"5 seconds remain!\"), TimeUnit.SECONDS, 5);\n</code></pre> Output:  <pre><code>Remaining Time: 10s\nRemaining Time: 9s\nRemaining Time: 8s\nRemaining Time: 7s\nRemaining Time: 6s\nRemaining Time: 5s\n5 seconds remain!\nRemaining Time: 4s\nRemaining Time: 3s\nRemaining Time: 2s\nRemaining Time: 1s\nRemaining Time: 0s\n</code></pre> If you notice, the new message happened at the same time as the 5 second count and didn't happen again. The order isn't guarunteed due to the fact it uses a HashMap behind the scenes and not a linked one.  </p> <p>If I bump up the total clock time to 15 seconds, it still works <pre><code>Remaining Time: 15s\nRemaining Time: 14s\nRemaining Time: 13s\nRemaining Time: 12s\nRemaining Time: 11s\nRemaining Time: 10s\nRemaining Time: 9s\nRemaining Time: 8s\nRemaining Time: 7s\nRemaining Time: 6s\nRemaining Time: 5s\n5 seconds remain!\nRemaining Time: 4s\nRemaining Time: 3s\nRemaining Time: 2s\nRemaining Time: 1s\nRemaining Time: 0s\n</code></pre></p>"},{"location":"clocks/","title":"Clocks and how they work","text":"<p>The <code>Clock</code> class is the base class for all clocks within StarClock. It contains much of the base functionality of each one to make it much simpler to maintain. The <code>Timer</code> and <code>Stopwatch</code> are the two implementations of the Clock class, and really, you should extend from one of these two if you want to do such things. See the callbacks page for how those work as they require their own explaination. Going forward, we will be referencing the source of the Clock class. You may want to take a look at it to see what I am talking about.  </p>"},{"location":"clocks/#ticking","title":"Ticking","text":"<p>Clocks use a \"ticking\" concept, this is whenever the runnable processes clocks, this is based on the <code>countAmount</code>. So if the <code>countAmount</code> is one. It will \"tick\" every millisecond. This allows customization of how precise you want to have your clocks to be. I do recommend choosing the lowest option feasable. The <code>countAmount</code> determine the shortest time that a callback can run.  </p>"},{"location":"clocks/#snapshots","title":"Snapshots","text":"<p>Clock Snapshots are a way of preserving the clock state when it is going to process callbacks. These are thread-safe and changes to snapshots are not reflected in clocks. </p>"},{"location":"clocks/#pausing-and-unpausing","title":"Pausing and Unpausing","text":"<p>This is just a boolean flag to tell the ClockRunnable to skip this clock if it is true. Nothing else happens when paused and this is the default state when creating a clock.  </p>"},{"location":"clocks/#cancelling-and-uncancelling","title":"Cancelling and uncancelling","text":"<p>When you cancel a clock, it will remove the clock from the ClockManager on the next run, meaning you have until the next \"tick\" to uncancel the clock.  </p>"},{"location":"clocks/#non-ending","title":"Non-Ending","text":"<p>Clocks by default do not auto-cancel when they hit their upper or lower bounds. Timers when they hit zero and stopwatches when they hit their end time flag. You can change the time on a Timer and Stopwatch and it will behave just as if it didn't get changed. if you change a stopwatch's end time, it will continue to run the callbacks. If you change the Timer's length, it will accout for elapsed time and continue on.</p>"},{"location":"clocks/#end-condition","title":"End Condition","text":"<p>This is a functional interface to determine when a clock should end automatically. Callbacks SHOULD NOT be used to cancel a clock. Without an end condition, the clock will remain until the program ends, or it is cancelled. Returning <code>true</code> means that the clock will be cancelled. Returning <code>false</code> will mean the clock will continue to run. End Conditions are checked as the last thing, after all callbacks are processed. </p>"},{"location":"clocks/#the-properties","title":"The Properties","text":"<p>The <code>timeProperty</code> is something from StarLib and it allows detection of changes to a value without having to make sure there are methods for it. You can call the <code>timeProperty()</code> method and either add a bind or changelistener and it will function like a StarLib Property. In Timer, the length is a Property, and in Stopwatch, the endTime is a Property. these have methods that are named the same as the fields to allow the full functionality of a <code>Property</code> to be used. </p>"},{"location":"gettingstarted/","title":"Getting Started","text":"<p>This page will show you the prerequisits that you need to have in order to use this library</p>"},{"location":"gettingstarted/#timing-system","title":"Timing System","text":"<p>You must have some way of having repeated calls to a method using a <code>Runnable</code>. There are multiple ways that you can do this, however this is out of the scope of this Wiki. You can use the <code>java.util.Timer</code> or use the Spigot <code>Scheduler</code>. For the rest of this example, I will be using the Java Timer method so that I can have millisecond precision. </p>"},{"location":"gettingstarted/#installation","title":"Installation","text":"<p>Please see Installation to see how to install StarClock and StarLib</p>"},{"location":"gettingstarted/#clockmanager","title":"ClockManager","text":"<p>This class is the entry-point into the library. You must obtain an instance to this class in some way. The easiest way is to just create an instance of it, however, if you are using <code>StarCore</code>, you can obtain it using the <code>ServiceManager</code></p>"},{"location":"gettingstarted/#logger-parameter","title":"<code>logger</code> Parameter","text":"<p>This parameter is to allow printing of some information to the logger. This can be <code>null</code>. </p>"},{"location":"gettingstarted/#countamount-parameter","title":"<code>countAmount</code> Parameter","text":"<p>This parameter is how much time in <code>milliseconds</code> that the clocks registered to this manager count by. It is recommended to use the lowest denomination that you wish to use. For this example, I will be using 1 millisecond. For Spigot/Paper, the lowest that you can do is <code>50</code> milliseconds. </p>"},{"location":"gettingstarted/#example-creation","title":"Example Creation","text":"<pre><code>ClockManager clockManager = new ClockManager(null, 1);\n</code></pre>"},{"location":"installation/","title":"Installing StarClock and StarLib","text":"<p>The first thing you need to determine is the version of StarClock that you are using. Go to the releases page on the GitHub and look for the <code>latest</code>. The release description will have which version(s) of StarLib work with StarClock. If no version of StarLib is listed, the latest version of StarLib is assumed.  </p>"},{"location":"installation/#choosing-a-build-tool","title":"Choosing a Build Tool","text":"<p>The two primary build tools for Java are Maven and Gradle. Pick one and stick with it.</p>"},{"location":"installation/#jitpack-repository","title":"JitPack Repository","text":"<p>Star Development LLC uses JitPack as the repository for development. You must have this repository in whichever build tool you wish to use.  </p>"},{"location":"installation/#maven","title":"Maven","text":"<pre><code>&lt;repositories&gt;\n    &lt;repository&gt;\n        &lt;id&gt;jitpack.io&lt;/id&gt;\n        &lt;url&gt;https://jitpack.io&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre>"},{"location":"installation/#gradle","title":"Gradle","text":"<pre><code>repositories {\n    maven { url 'https://jitpack.io' }\n}\n</code></pre>"},{"location":"installation/#starlib","title":"StarLib","text":"<p>StarLib is an essential library used within StarClock, however, it does not package it by default, this is to allow compatibility with other projects as to not have too many duplicate dependencies. Please ensure you are installing the correct version of StarLib for the version of StarClock that you are using, see above for how to find this information. Replace <code>{VERSION}</code> with the version of StarLib you are using!</p>"},{"location":"installation/#maven_1","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.StarDevelopmentLLC&lt;/groupId&gt;\n    &lt;artifactId&gt;StarLib&lt;/artifactId&gt;\n    &lt;version&gt;{VERSION}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"installation/#gradle_1","title":"Gradle","text":"<pre><code>dependencies {\n    implementation 'com.github.StarDevelopmentLLC:StarLib:{VERSION}'\n}\n</code></pre>"},{"location":"installation/#starclock","title":"StarClock","text":""},{"location":"installation/#maven_2","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.StarDevelopmentLLC&lt;/groupId&gt;\n    &lt;artifactId&gt;StarClock&lt;/artifactId&gt;\n    &lt;version&gt;{VERSION}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"installation/#gradle_2","title":"Gradle","text":"<pre><code>dependencies {\n    implementation 'com.github.StarDevelopmentLLC:StarClock:{VERSION}'\n}\n</code></pre>"},{"location":"stopwatch/","title":"Stopwatch","text":"<p>~~# Stopwatch This type of clock is a <code>count up</code> type of clock, meaning it will start from zero and go until the end time, or until it stops. You MUST provide an end time. If you don't bad things will happen. This is a bug as of now, and a future update will fix this issue.  </p>"},{"location":"stopwatch/#creation","title":"Creation","text":"<p>There are two ways that you can use to create a Stopwatch, using the <code>new</code> keyword and the ClockManager instance. </p>"},{"location":"stopwatch/#clockmanager-factory-method","title":"ClockManager Factory Method","text":"<p>The clockManager factory method <code>createStopwatch(long)</code> allows you to easily create a new stopwatch without having to worry about constructor parameters. The <code>long</code> parameter is the end time for the stopwatch. </p> <p><pre><code>Stopwatch stopwatch = clockManager.createStopwatch(TimeUnit.SECONDS.toMillis(10));\n</code></pre> Note: I am using the <code>TimeUnit</code> from StarLib, which StarClock needs to have on the class-path</p>"},{"location":"stopwatch/#constructor-method","title":"Constructor Method","text":"<p>For this way of creation, you cannot do it all in one line, instead you have to create an instance of it, then pass it into the <code>addClock()</code> method in the ClockManager instance. You also have to provide the countAmount value to the constructor as well.  </p> <pre><code>Stopwatch stopwatch = new Stopwatch(TimeUnit.SECONDS.toMillis(10), clockManager.getCountAmount());\nclockManager.addClock(stopwatch);\n</code></pre> <p>For what it is worth, it is best to use Factory method as it does all of this for you.  </p>"},{"location":"stopwatch/#usage","title":"Usage","text":"<p>In order to fully use a Stopwatch, you must understand callbacks. For that, please see the page Callbacks in order to go into depth about these. For this example, I will use a repeating callback to demonstrate. <pre><code>stopwatch.addRepeatingCallback(new ClockCallback&lt;StopwatchSnapshot&gt;() {\n    @Override\n    public void callback(StopwatchSnapshot snapshot) {\n        System.out.println(\"Clock Time: \" + TimeUnit.SECONDS.fromMillis(snapshot.getTime()) + \"s\");\n    }\n}, TimeUnit.SECONDS, 1);\nstopwatch.start();\n</code></pre></p> <p>The above code snippet is the full expanded, here is what it looks like if you use lamdas <pre><code>stopwatch.addRepeatingCallback(snapshot -&gt; System.out.println(\"Clock Time: \" + TimeUnit.SECONDS.fromMillis(snapshot.getTime()) + \"s\"), TimeUnit.SECONDS, 1);\nstopwatch.start();\n</code></pre></p> <p>If we run this code we get output every second and it will stop outputting at 10 seconds. <pre><code>Clock Time: 0s\nClock Time: 1s\nClock Time: 2s\nClock Time: 3s\nClock Time: 4s\nClock Time: 5s\nClock Time: 6s\nClock Time: 7s\nClock Time: 8s\nClock Time: 9s\nClock Time: 10s\n</code></pre> Please see Clocks to get a full explaination of the internal workings and what you can do with all clocks and on how to automatically end them.</p>"},{"location":"timer/","title":"Timer","text":"<p>This is the <code>count down</code> clock and is used for starting at a certain time and then ending when it hits zero.  </p>"},{"location":"timer/#creation","title":"Creation","text":"<p>There are two ways that you can use to create a Timer, using the <code>new</code> keyword and the ClockManager instance.</p>"},{"location":"timer/#clockmanager-factory-method","title":"ClockManager Factory Method","text":"<p>The clockManager factory method <code>createTimer(long)</code> allows you to easily create a new timer without having to worry about constructor parameters. The <code>long</code> parameter is the start time for the timer.</p> <p><pre><code>Timer timer = clockManager.createTimer(TimeUnit.SECONDS.toMillis(10));\n</code></pre> Note: I am using the <code>TimeUnit</code> from StarLib, which StarClock needs to have on the class-path</p>"},{"location":"timer/#constructor-method","title":"Constructor Method","text":"<p>For this way of creation, you cannot do it all in one line, instead you have to create an instance of it, then pass it into the <code>addClock()</code> method in the ClockManager instance. You also have to provide the countAmount value to the constructor as well.</p> <pre><code>Timer timer = new Timer(TimeUnit.SECONDS.toMillis(10), clockManager.getCountAmount());\nclockManager.addClock(timer);\n</code></pre> <p>For what it is worth, it is best to use Factory method as it does all of this for you.</p>"},{"location":"timer/#usage","title":"Usage","text":"<p>In order to fully use a Timer, you must understand callbacks. For that, please see the page Callbacks in order to go into depth about these. For this example, I will use a repeating callback to demonstrate. <pre><code>timer.addRepeatingCallback(new ClockCallback&lt;TimerSnapshot&gt;() {\n    @Override\n    public void callback(TimerSnapshot snapshot) {\n        System.out.println(\"Remaining Time: \" + TimeUnit.SECONDS.fromMillis(snapshot.getTime()) + \"s\");\n    }\n}, TimeUnit.SECONDS, 1);\ntimer.start();\n</code></pre></p> <p>The above code snippet is the full expanded, here is what it looks like if you use lamdas <pre><code>timer.addRepeatingCallback(snapshot -&gt; System.out.println(\"Remaining Time: \" + TimeUnit.SECONDS.fromMillis(snapshot.getTime()) + \"s\"), TimeUnit.SECONDS, 1);\ntimer.start();\n</code></pre></p> <p>If we run this code we get output every second and it will stop outputting at 10 seconds. <pre><code>Remaining Time: 10s\nRemaining Time: 9s\nRemaining Time: 8s\nRemaining Time: 7s\nRemaining Time: 6s\nRemaining Time: 5s\nRemaining Time: 4s\nRemaining Time: 3s\nRemaining Time: 2s\nRemaining Time: 1s\nRemaining Time: 0s\n</code></pre> Please see Clocks to get a full explaination of the internal workings and what you can do with all clocks and on how to automatically end them.</p>"}]}